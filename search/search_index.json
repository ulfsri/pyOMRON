{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyOMRON","text":"<p>Python API for acquisition and control of OMRON G3PW Power Controller.</p> <p>See OMRON G3PW User Manual \u00a76 for reference.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pyOMRON\n</code></pre> <p>or install with <code>Poetry</code></p> <pre><code>poetry add pyOMRON\n</code></pre>"},{"location":"#makefile-usage","title":"Makefile usage","text":"<p><code>Makefile</code> contains a lot of functions for faster development.</p> 1. Download and remove Poetry <p>  To download and install Poetry run:  <pre><code>make poetry-download\n</code></pre>  To uninstall  <pre><code>make poetry-remove\n</code></pre> </p> 2. Install all dependencies and pre-commit hooks <p>  Install requirements:  <pre><code>make install\n</code></pre>  Pre-commit hooks coulb be installed after `git init` via  <pre><code>make pre-commit-install\n</code></pre> </p> 3. Codestyle <p>  Automatic formatting uses `pyupgrade`, `isort` and `black`.  <pre><code>make codestyle\n\n# or use synonym\nmake formatting\n</code></pre>  Codestyle checks only, without rewriting files:  <pre><code>make check-codestyle\n</code></pre>  &gt; Note: `check-codestyle` uses `isort`, `black` and `darglint` library  Update all dev libraries to the latest version using one comand  <pre><code>make update-dev-deps\n</code></pre> 4. Code security <p> <pre><code>make check-safety\n</code></pre>  This command launches `Poetry` integrity checks as well as identifies security issues with `Safety` and `Bandit`.  <pre><code>make check-safety\n</code></pre> </p> </p> 5. Type checks <p>  Run `mypy` static type checker  <pre><code>make mypy\n</code></pre> </p> 6. Tests with coverage badges <p>  Run `pytest`  <pre><code>make test\n</code></pre> </p> 7. All linters <p>  Of course there is a command to ~~rule~~ run all linters in one:  <pre><code>make lint\n</code></pre>  the same as:  <pre><code>make test &amp;&amp; make check-codestyle &amp;&amp; make mypy &amp;&amp; make check-safety\n</code></pre> </p> 8. Docker <p> <pre><code>make docker-build\n</code></pre>  which is equivalent to:  <pre><code>make docker-build VERSION=latest\n</code></pre>  Remove docker image with  <pre><code>make docker-remove\n</code></pre>  More information [about docker](https://github.com/ulfsri/pyOMRON/tree/main/docker).  </p> 9. Cleanup <p> Delete pycache files  <pre><code>make pycache-remove\n</code></pre>  Remove package build  <pre><code>make build-remove\n</code></pre>  Delete .DS_STORE files  <pre><code>make dsstore-remove\n</code></pre>  Remove .mypycache  <pre><code>make mypycache-remove\n</code></pre>  Or to remove all above run:  <pre><code>make cleanup\n</code></pre> </p>"},{"location":"#releases","title":"\ud83d\udcc8 Releases","text":"<p>You can see the list of available releases on the GitHub Releases page.</p> <p>We follow Semantic Versions specification.</p> <p>We use <code>Release Drafter</code>. As pull requests are merged, a draft release is kept up-to-date listing the changes, ready to publish when you\u2019re ready. With the categories option, you can categorize pull requests in release notes using labels.</p>"},{"location":"#list-of-labels-and-corresponding-titles","title":"List of labels and corresponding titles","text":"Label Title in Releases <code>enhancement</code>, <code>feature</code> \ud83d\ude80 Features <code>bug</code>, <code>refactoring</code>, <code>bugfix</code>, <code>fix</code> \ud83d\udd27 Fixes &amp; Refactoring <code>build</code>, <code>ci</code>, <code>testing</code> \ud83d\udce6 Build System &amp; CI/CD <code>breaking</code> \ud83d\udca5 Breaking Changes <code>documentation</code> \ud83d\udcdd Documentation <code>dependencies</code> \u2b06\ufe0f Dependencies updates <p>You can update it in <code>release-drafter.yml</code>.</p> <p>GitHub creates the <code>bug</code>, <code>enhancement</code>, and <code>documentation</code> labels for you. Dependabot creates the <code>dependencies</code> label. Create the remaining labels on the Issues tab of your GitHub repository, when you need them.</p>"},{"location":"#license","title":"\ud83d\udee1 License","text":"<p>This project is licensed under the terms of the <code>MIT</code> license. See LICENSE for more details.</p>"},{"location":"#citation","title":"\ud83d\udcc3 Citation","text":"<pre><code>@misc{pyOMRON,\n  author = {ulfsri},\n  title = {Python API for acquisition and control of OMRON G3PW Power Controller},\n  year = {2024},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/ulfsri/pyOMRON}}\n}\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This project was generated with <code>python-package-template</code></p>"},{"location":"device-reference/","title":"Device module","text":"<p>Module for the OMRON power controller device.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a G3PW device.</p> <p>Returns:</p> Name Type Description <code>Device</code> <p>The new device.</p>"},{"location":"device-reference/#pyomron.device.Omron","title":"<code>Omron</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Omron class.</p> Source code in <code>pyomron/device.py</code> <pre><code>class Omron(ABC):\n    \"\"\"Omron class.\"\"\"\n\n    codes_path = importlib.resources.files(\"pyomron\").joinpath(\"codes.json\")\n    with open(codes_path) as f:\n        codes = json.load(f)\n    addresses = codes[\"addresses\"][0]\n    C383_notation = codes[\"C383_notation\"][0]\n    status_labels = codes[\"status_labels\"]\n\n    def __init__(self, device: SerialDevice, unit_no: int = 1, **kwargs: Any) -&gt; None:\n        \"\"\"Initializes the Device object.\n\n        Args:\n            device (SerialDevice): The serial device object.\n            unit_no (int, optional): The device unit number. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._device = device\n        self._dev_info = None\n        self._unit_no = unit_no\n\n    @classmethod\n    async def new_device(cls, port: str, unit_no: int = 1, **kwargs: Any) -&gt; Self:\n        \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n        Example:\n            dev = run(Omron.new_device, \"/dev/ttyUSB6\")\n\n        Args:\n            port (str): The port to connect to.\n            unit_no (int, optional): The unit number. Defaults to 1.\n            **kwargs: Any\n\n        Returns:\n            Device: The new device.\n        \"\"\"\n        if port.startswith(\"/dev/\"):\n            device = SerialDevice(port, **kwargs)\n        byte_list = [\n            \"\\x30\",\n            \"\\x35\",\n            \"\\x30\",\n            \"\\x33\",\n        ]  # Command for controller attribute read\n        byte_list = await cls._prepend(byte_list, unit_no)\n        byte_list = await cls._append(byte_list)\n        byte = bytes(\"\".join(byte_list), \"ascii\")\n        byte += bytes([await cls._bcc_calc(byte_list)])\n        resp = await device._write_readline(byte)\n        await cls._check_end_code(resp)\n        await cls._check_response_code(resp)\n        ret = resp[15:-6].decode(\"ascii\")\n        # Chek using is_model class to see if it matches G3PW\n        if await cls._is_model(ret):\n            return cls(device, unit_no, **kwargs)\n        else:\n            raise ValueError(\"Device is not G3PW\")\n\n    @classmethod\n    async def _prepend(cls, frame: list[str], unit_no: int = 1) -&gt; list[str]:\n        \"\"\"Prepends the frame with the device id.\n\n        Args:\n            frame (list[str]): Command frame to prepend to\n            unit_no (int, optional): The unit number. Defaults to 1.\n\n        Returns:\n            list[str]: Frame with prepended info\n        \"\"\"\n        if unit_no and type(unit_no) != int:\n            unit_no = int(unit_no, 16)\n        n = hex(unit_no)\n        digs = list(n[2:].upper())\n        if len(digs) &lt; 2:\n            digs.insert(0, \"\\x30\")\n        return (\n            [\n                \"\\x02\"  # STX\n            ]\n            + digs  # Unit No.\n            + [\n                \"\\x30\",  # Sub-address\n                \"\\x30\",  # Sub-address\n                \"\\x30\",  # SID\n            ]\n            + frame\n        )\n\n    @classmethod\n    async def _append(cls, frame: list[str]) -&gt; list[str]:\n        \"\"\"Appends the frame with the ETX.\n\n        Args:\n            frame (list[str]): Command frame to append to\n\n        Returns:\n            list[str]: Frame with appended info\n        \"\"\"\n        return frame + [\"\\x03\"]  # ETX\n\n    @classmethod\n    async def _bcc_calc(cls, frame: list[str]) -&gt; int:\n        \"\"\"Calculates the BCC of the frame.\n\n        Args:\n            frame (list[str]prepend): List of values in frame to use to find BCC\n\n        Returns:\n            bcc (int): Calculated BCC\n        \"\"\"\n        bcc = 0\n        for byte in frame[1:]:\n            bcc ^= ord(byte)  # Take the XOR of all the bytes in the frame\n        return bcc\n\n    @classmethod\n    async def _is_model(cls, model: str) -&gt; bool:\n        \"\"\"Checks if the device is the correct model.\n\n        Args:\n            model (str): The model to check against\n\n        Returns:\n            bool: True if the model is correct, False otherwise\n        \"\"\"\n        return model[0:4] == \"G3PW\"\n\n    async def _comm_frame(self, frame: list[str]) -&gt; bytes:\n        \"\"\"Builds the communication frame.\n\n        Args:\n            frame (list[str]): Command frame to build\n\n        Returns:\n            list: Communication frame\n        \"\"\"\n        byte_list = await self._prepend(frame, self._unit_no)\n        byte_list = await self._append(byte_list)\n        byte = bytes(\"\".join(byte_list), \"ascii\")\n        byte += bytes([await self._bcc_calc(byte_list)])\n        return byte\n\n    @classmethod\n    async def _check_end_code(cls, ret: bytearray) -&gt; None:\n        \"\"\"Checks if the end code is 00.\n\n        If an error is present, the error name is printed.\n\n        Args:\n            ret (bytearray): Response from device\n\n        Raises:\n            ValueError: If an error is present\n\n        Returns:\n            None\n        \"\"\"\n        error_codes = {\n            bytes(\"00\", \"ascii\"): \"Normal Completion\",\n            bytes(\"0F\", \"ascii\"): \"FINS command error\",\n            bytes(\"10\", \"ascii\"): \"Parity error\",\n            bytes(\"11\", \"ascii\"): \"Framing error\",\n            bytes(\"12\", \"ascii\"): \"Overrun error\",\n            bytes(\"13\", \"ascii\"): \"BCC error\",\n            bytes(\"14\", \"ascii\"): \"Format error\",\n            bytes(\"16\", \"ascii\"): \"Sub-address error\",\n            bytes(\"18\", \"ascii\"): \"Frame length error\",\n        }\n        error_code = ret[5:7]\n        if error_code != bytes(\"00\", \"ascii\"):\n            # print(error_code)\n            # print(error_codes.get(bytes(error_code), \"Unknown Error\"))\n            raise ValueError(f\"{error_codes.get(bytes(error_code), \"Unknown Error\")}\")\n        return\n\n    @classmethod\n    async def _check_response_code(cls, ret: bytearray) -&gt; None:\n        \"\"\"Checks if the response code is 0000.\n\n        If an error is present, the error name is printed.\n\n        Args:\n            ret (bytearray): Response from device\n\n        Raises:\n            ValueError: If an error is present\n\n        Returns:\n            None\n        \"\"\"\n        response_codes = {\n            bytes(\"1001\", \"ascii\"): \"Command length too long\",\n            bytes(\"1002\", \"ascii\"): \"Command length too short\",\n            bytes(\"1003\", \"ascii\"): \"Number of elements/Number of data do not agree\",\n            bytes(\"1101\", \"ascii\"): \"Area Type Error\",\n            bytes(\"110B\", \"ascii\"): \"Response length too long\",\n            bytes(\"1100\", \"ascii\"): \"Parameter error\",\n            bytes(\"2203\", \"ascii\"): \"Operation error\",\n        }\n        response_code = ret[11:15]\n        if response_code != bytes(\"0000\", \"ascii\"):\n            # print(response_codes.get(bytes(response_code), \"Unknown Error\"))\n            raise ValueError(\n                f\"{response_codes.get(bytes(response_code), \"Unknown Error\")}\"\n            )\n        return\n\n    async def _variable_area_write(\n        self, var_addr: str, set_values: float | list[float]\n    ) -&gt; None:\n        \"\"\"Changes set values.\n\n        Automatically handles if multiple consecutive addresses are being written to.\n\n        Args:\n            var_addr (str): The desired variable type and starting address\n            set_values (float | list[float]): The value the variable should be set to.\n        \"\"\"\n        if isinstance(set_values, list):\n            num_elem = len(set_values)  # Number of elements to write\n        else:\n            num_elem = 1\n            set_values = [set_values]  # Convert to list if not already\n        command_data = []\n\n        for i, c in enumerate(var_addr):\n            command_data.append(c)  # Add each byte to the command_data list\n\n        # Builds beginning portion of the FINS-mini command\n        byte_list = (\n            [\"\\x30\", \"\\x31\", \"\\x30\", \"\\x32\"]  # MRC  # MRC  # SRC  # SRC\n            + command_data  # command\n            + [\"\\x30\", \"\\x30\"]  # Bit Position  # Bit Position\n        )\n\n        # Add the number of elements to the FINS-mini command\n        num_elem = (\n            f\"{hex(num_elem)[2:]:0&gt;4}\".upper()\n        )  # Converts the number of elements to hex string\n        for i, c in enumerate(num_elem):\n            byte_list.append(c)\n\n        # Add the set values to the FINS-mini command\n        for i, set_value in enumerate(set_values):\n            # Checks for 'Status', 'Version', or 'Heater Burnout Threshold' commands\n            # TODO: This 'if' statement needs to check for all addresses that are being written to, the command variable just stores the starting address\n            # Or maybe we need to come up with a better system for doing this. It could be done in the set() function by the address name and then passed to the write function with the value appropriately scaled\n            if (\n                var_addr[1] == \"E\"\n                and (int(var_addr[5]) != 6 or int(var_addr[4:5]) != 14)\n            ) or (var_addr[1] == \"1\" and int(var_addr[5], 16) != 14):\n                set_value = int(float(set_value * 10))\n\n            # Converts the set value to a hex string\n            if var_addr[0] == \"C\":  # 8 bytes\n                set_value = f\"{hex(set_value)[2:]:0&gt;8}\".upper()\n            elif var_addr[0] == \"8\":  # 4 bytes\n                set_value = f\"{hex(set_value)[2:]:0&gt;4}\".upper()\n            for i, c in enumerate(set_value):\n                byte_list.append(c)\n\n        # Build the communication frame\n        byte = await self._comm_frame(byte_list)\n\n        resp = await self._device._write_readline(byte)\n\n        await self._check_end_code(resp)\n        await self._check_response_code(resp)\n\n        return\n\n    async def _variable_area_read(\n        self, var_addr: str, num_elem: int = 1\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Reads set values.\n\n        Args:\n            var_addr (str): The desired variable type and starting address\n            num_elem (int): The number of elements to read. Defaults to 1.\n\n        Returns:\n            dict[str, str | float]: Variable:Value pair for each variable read\n        \"\"\"\n        command_data = []\n        ret_dict = {}\n\n        for i, c in enumerate(var_addr):\n            command_data.append(c)  # Add each byte to the command_data list\n\n        # Builds beginning portion of the FINS-mini command\n        byte_list = (\n            [\"\\x30\", \"\\x31\", \"\\x30\", \"\\x31\"]  # MRC  # MRC  # SRC  # SRC\n            + command_data  # command\n            + [\"\\x30\", \"\\x30\"]  # Bit Position  # Bit Position\n        )\n\n        # Converts the number of elements to hex\n        num_elem = f\"{hex(num_elem)[2:]:0&gt;4}\".upper()\n        # Add the number of elements to the FINS-mini command\n        for i, c in enumerate(num_elem):\n            byte_list.append(c)\n\n        # Build the communication frame, prepends and appends\n        byte = await self._comm_frame(byte_list)\n\n        resp = await self._device._write_readline(byte)\n\n        await self._check_end_code(resp)\n        await self._check_response_code(resp)\n\n        resp = resp[15:-2]  # Removes everything but the set values from the response\n\n        # Get metadata from the return. Questionable if we need this because it's given in the function call\n        var_type = byte[10:12].decode(\"ascii\")  # Variable type read from\n        read_start = int(byte[12:16], 16)  # Address to start reading from\n        num_elem = int(byte[18:22], 16)  # Number of elements to read\n\n        # Fill in the dictionary with the address: value pairs\n        for i in range(num_elem):  # Loop through the each of the elements read\n            addr = f\"{hex(read_start + i)[2:]:0&gt;4}\".upper()  # Address of the element\n            if var_type[0] == \"C\":  # The 8 bit case\n                ret_dict[self.addresses[var_type][addr]] = int(\n                    resp[0 + 8 * i : 8 + 8 * i].decode(\"ascii\"), 16\n                )\n            elif var_type[0] == \"8\":  # The 4 bit case\n                ret_dict[self.addresses[var_type][addr]] = int(\n                    resp[0 + 4 * i : 4 + 4 * i].decode(\"ascii\"), 16\n                )\n            else:\n                # print(\"Error in Variable Type\")\n                raise ValueError(\"Variable Type Error\")\n\n        # Convert data to readable notation\n        for key, value in ret_dict.items():\n            if var_type[1] in [\"E\", \"1\"]:\n                if key == \"Version\":\n                    ret_dict[key] = value / 100\n                elif key == \"Status\":\n                    return await self.status(value)\n                elif key == \"Heater Burnout Threshold\":\n                    ret_dict[key] = value\n                else:\n                    ret_dict[key] = value / 10\n            else:\n                try:\n                    note = self.C383_notation[key][str(value)]\n                except KeyError:\n                    note = None\n                if note:\n                    ret_dict[key] = note\n                elif key in [\n                    \"Input Digital Filter Time Constant\",\n                    \"Load Current Upper Limit\",\n                    \"Total Run Time Alarm Set Value\",\n                ]:\n                    ret_dict[key] = value / 10\n                else:\n                    ret_dict[key] = value\n        return ret_dict\n\n    async def status(self, value: str) -&gt; dict[str, str]:\n        \"\"\"Reads the operating and error status from a bit field.\n\n        Args:\n            value (str): The bit field to read from\n\n        Returns:\n            dict[str, str]: Value of each Protection/Error Operation\n        \"\"\"\n        e_m = {0: \"No Error\", 1: \"Error\"}\n        p_m = {0: \"OFF\", 1: \"ON\"}\n        status = [\"Q\"] * 32\n        for i in range(32):\n            if i in [7, 12, 13, 14, 15]:\n                continue\n            elif i &lt; 16:\n                status[i] = e_m[(value &gt;&gt; i) &amp; 1]\n            elif i == 19:\n                status[i] = (\n                    \"Initial Setting Level\" if (value &gt;&gt; i) &amp; 1 else \"Operation Level\"\n                )\n            elif i == 20:\n                status[i] = \"Manual\" if (value &gt;&gt; i) &amp; 1 else \"Automatic\"\n            elif i == 21:\n                status[i] = (\n                    \"Optimum Cycle Control\" if (value &gt;&gt; i) &amp; 1 else \"Phase Control\"\n                )\n            elif i &lt; 32:\n                status[i] = p_m[(value &gt;&gt; i) &amp; 1]\n        ret_dict = dict(zip(self.status_labels, status))\n        del ret_dict[\"Not used.\"]\n        return ret_dict\n\n    async def controller_attribute_read(self) -&gt; str:\n        \"\"\"Reads the controller attribute.\n\n        Returns:\n            str: Response from device\n        \"\"\"\n        byte_list = [\n            \"\\x30\",\n            \"\\x35\",\n            \"\\x30\",\n            \"\\x33\",\n        ]  # Command for controller attribute read\n        byte = await self._comm_frame(byte_list)\n        resp = await self._device._write_readline(byte)\n        await self._check_response_code(resp)\n        ret = resp[15:-6].decode(\"ascii\")\n        self._device_info = ret\n        return ret\n\n    async def controller_status_read(self) -&gt; str:\n        \"\"\"Reads the operating and error status.\n\n        Returns:\n            str: Response from device\n        \"\"\"\n        byte_list = [\n            \"\\x30\",\n            \"\\x36\",\n            \"\\x30\",\n            \"\\x31\",\n        ]  # Command for controller status read\n        byte = await self._comm_frame(byte_list)\n        resp = await self._device._write_readline(byte)\n        await self._check_response_code(resp)\n        ret = resp[15:-4].decode(\"ascii\")\n        return ret\n\n    async def echo_back_test(self, test_input: int = 0) -&gt; None:\n        \"\"\"Performs an echo back test.\n\n        This is used for debugging purposes.\n\n        Args:\n            test_input (int): The number to echo back. Defaults to 0.\n        \"\"\"\n        test_data = []\n        while test_input &gt; 0:\n            test_data.insert(0, ascii(test_input % 10))\n            test_input = int(test_input / 10)\n        byte_list = [\n            \"\\x30\",\n            \"\\x38\",\n            \"\\x30\",\n            \"\\x31\",\n        ] + test_data  # '0801' is echo-back command\n        byte = await self._comm_frame(byte_list)\n        resp = await self._device._write_readline(byte)\n        await self._check_end_code(resp)\n        resp = resp.hex()\n        if resp[23] != \"0\" or resp[25] != \"0\" or resp[27] != \"0\" or resp[29] != \"0\":\n            # print(\"Error occured\")\n            raise RuntimeError(\"Unknown Error\")\n        # print(f\"Result = {bytes.fromhex(resp[30:-4]).decode('ascii')}\")\n        return\n\n    async def get(\n        self, comm: list[str] = \"\", ignoreError: bool = False\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets the current value of the device.\n\n        Example:\n            df = run(dev.get, [\"Version\", \"Communications Main Setting 1\", \"Communications Parity\"])\n            df = run(dev.get, \"Status\")\n\n        Args:\n            comm (list[str]): List of variables for the device to retrieve\n            ignoreError (bool): If False, not finding one value raises an error. If True, everything else returned. Defaults to False.\n\n        Returns:\n            dict[str, str | float]: All variable:value pairs for each item in comm\n        \"\"\"\n        if not comm:\n            return await self.monitors()\n        if not isinstance(comm, list):\n            comm = [comm]\n        # Makes a dictionary to store the results\n        ret_dict = {}\n        comm_list = []\n        for c in comm:\n            # Search through addresses to find the address for the comm\n            for var_type, dict in self.addresses.items():\n                for add, command in dict.items():\n                    if c == command:\n                        comm_add = var_type + add\n                        if comm_add == \"8E0006\":\n                            comm_add = \"CE0006\"\n                        if (\n                            \"8\" + comm_add[1:] not in comm_list\n                            and \"C\" + comm_add[1:] not in comm_list\n                        ):\n                            comm_list.append(comm_add)\n            # Calls read and adds the result to the dictionary\n        comm_list.sort()\n        # print(comm_list)\n        i = 0\n        while i &lt;= len(comm_list) - 1:\n            k = 1\n            # print(f\"Looking from: {hex(int(comm_list[i], 16))[2:].upper()}\")\n            for j in range(8):\n                if hex(int(comm_list[i], 16) + j)[2:].upper() in comm_list:\n                    # print(\"Found: \" + hex(int(comm_list[i], 16) + j)[2:].upper())\n                    idx = comm_list.index(hex(int(comm_list[i], 16) + j)[2:].upper())\n                    k = j + 1\n            # print(f\"Calling read with {comm_list[i]}, length {k}\")\n            ret_dict.update(await self._variable_area_read(comm_list[i], k))\n            if k &gt; 1:\n                i = idx\n            i += 1\n        for c in list(ret_dict.keys()):\n            if c not in comm and c not in self.status_labels:\n                del ret_dict[c]\n        if (\n            \"Status\" not in comm\n            and len(comm) != len(ret_dict)\n            or \"Status\" in comm\n            and len(comm) != len(ret_dict) - 16\n        ) and not ignoreError:\n            # print(f\"comm is {comm}, ret_dict is {ret_dict}\")\n            # print(f\"Error: Not all values were read.\")\n            raise KeyError(\"Not all values were read.\")\n        return ret_dict\n\n    async def set(self, comm: dict[str, str | float]) -&gt; None:\n        \"\"\"Sets value of comm to val.\n\n        Todo:\n            * Could also smartly manage writing if multiple sequential addresses are requested by using one call to variable_area_write() with necessary length but this is low priority because it's not likely we would run into this scenario often\n\n        Example:\n            df = run(dev.set, {\"Communications Parity\": \"Odd\", 'Output Upper Limit': 100})\n\n        Args:\n            comm (dict[str, str | float]): Command to change in form comm:val\n        \"\"\"\n        # Search through addresses to find the address for the comm\n        for c in list(comm.keys()):\n            for var_type, dict in self.addresses.items():\n                for add, command in dict.items():\n                    if c == command:\n                        comm_add = var_type + add\n            for var_type, dict in self.C383_notation.items():\n                for add, command in dict.items():\n                    if comm[c] == command:\n                        comm[c] = add\n            await self._variable_area_write(comm_add, int(comm[c]))  # Sets the value\n        return\n\n    async def heat(self, setpoint: float) -&gt; None:\n        \"\"\"Convenience: Sets the heater setpoint.\n\n        Example:\n            df = run(dev.heat, 0.0)\n\n        Args:\n            setpoint (float): The desired setpoint\n        \"\"\"\n        await self.set({\"Communications_Main_Setting_1\": setpoint})\n        return\n\n    async def monitors(self) -&gt; dict[str, float]:\n        \"\"\"Convenience: Gets the current monitor values.\n\n        Example:\n            df = run(dev.monitors)\n\n        Args:\n            setpoint (dict[str, float]): The desired setpoint\n        \"\"\"\n        return await self._variable_area_read(\"8E0000\", 6)\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.__init__","title":"<code>__init__(device, unit_no=1, **kwargs)</code>","text":"<p>Initializes the Device object.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>SerialDevice</code> <p>The serial device object.</p> required <code>unit_no</code> <code>int</code> <p>The device unit number. Defaults to 1.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>pyomron/device.py</code> <pre><code>def __init__(self, device: SerialDevice, unit_no: int = 1, **kwargs: Any) -&gt; None:\n    \"\"\"Initializes the Device object.\n\n    Args:\n        device (SerialDevice): The serial device object.\n        unit_no (int, optional): The device unit number. Defaults to 1.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._device = device\n    self._dev_info = None\n    self._unit_no = unit_no\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.controller_attribute_read","title":"<code>controller_attribute_read()</code>  <code>async</code>","text":"<p>Reads the controller attribute.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response from device</p> Source code in <code>pyomron/device.py</code> <pre><code>async def controller_attribute_read(self) -&gt; str:\n    \"\"\"Reads the controller attribute.\n\n    Returns:\n        str: Response from device\n    \"\"\"\n    byte_list = [\n        \"\\x30\",\n        \"\\x35\",\n        \"\\x30\",\n        \"\\x33\",\n    ]  # Command for controller attribute read\n    byte = await self._comm_frame(byte_list)\n    resp = await self._device._write_readline(byte)\n    await self._check_response_code(resp)\n    ret = resp[15:-6].decode(\"ascii\")\n    self._device_info = ret\n    return ret\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.controller_status_read","title":"<code>controller_status_read()</code>  <code>async</code>","text":"<p>Reads the operating and error status.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response from device</p> Source code in <code>pyomron/device.py</code> <pre><code>async def controller_status_read(self) -&gt; str:\n    \"\"\"Reads the operating and error status.\n\n    Returns:\n        str: Response from device\n    \"\"\"\n    byte_list = [\n        \"\\x30\",\n        \"\\x36\",\n        \"\\x30\",\n        \"\\x31\",\n    ]  # Command for controller status read\n    byte = await self._comm_frame(byte_list)\n    resp = await self._device._write_readline(byte)\n    await self._check_response_code(resp)\n    ret = resp[15:-4].decode(\"ascii\")\n    return ret\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.echo_back_test","title":"<code>echo_back_test(test_input=0)</code>  <code>async</code>","text":"<p>Performs an echo back test.</p> <p>This is used for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>test_input</code> <code>int</code> <p>The number to echo back. Defaults to 0.</p> <code>0</code> Source code in <code>pyomron/device.py</code> <pre><code>async def echo_back_test(self, test_input: int = 0) -&gt; None:\n    \"\"\"Performs an echo back test.\n\n    This is used for debugging purposes.\n\n    Args:\n        test_input (int): The number to echo back. Defaults to 0.\n    \"\"\"\n    test_data = []\n    while test_input &gt; 0:\n        test_data.insert(0, ascii(test_input % 10))\n        test_input = int(test_input / 10)\n    byte_list = [\n        \"\\x30\",\n        \"\\x38\",\n        \"\\x30\",\n        \"\\x31\",\n    ] + test_data  # '0801' is echo-back command\n    byte = await self._comm_frame(byte_list)\n    resp = await self._device._write_readline(byte)\n    await self._check_end_code(resp)\n    resp = resp.hex()\n    if resp[23] != \"0\" or resp[25] != \"0\" or resp[27] != \"0\" or resp[29] != \"0\":\n        # print(\"Error occured\")\n        raise RuntimeError(\"Unknown Error\")\n    # print(f\"Result = {bytes.fromhex(resp[30:-4]).decode('ascii')}\")\n    return\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.get","title":"<code>get(comm='', ignoreError=False)</code>  <code>async</code>","text":"<p>Gets the current value of the device.</p> Example <p>df = run(dev.get, [\"Version\", \"Communications Main Setting 1\", \"Communications Parity\"]) df = run(dev.get, \"Status\")</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>list[str]</code> <p>List of variables for the device to retrieve</p> <code>''</code> <code>ignoreError</code> <code>bool</code> <p>If False, not finding one value raises an error. If True, everything else returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: All variable:value pairs for each item in comm</p> Source code in <code>pyomron/device.py</code> <pre><code>async def get(\n    self, comm: list[str] = \"\", ignoreError: bool = False\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets the current value of the device.\n\n    Example:\n        df = run(dev.get, [\"Version\", \"Communications Main Setting 1\", \"Communications Parity\"])\n        df = run(dev.get, \"Status\")\n\n    Args:\n        comm (list[str]): List of variables for the device to retrieve\n        ignoreError (bool): If False, not finding one value raises an error. If True, everything else returned. Defaults to False.\n\n    Returns:\n        dict[str, str | float]: All variable:value pairs for each item in comm\n    \"\"\"\n    if not comm:\n        return await self.monitors()\n    if not isinstance(comm, list):\n        comm = [comm]\n    # Makes a dictionary to store the results\n    ret_dict = {}\n    comm_list = []\n    for c in comm:\n        # Search through addresses to find the address for the comm\n        for var_type, dict in self.addresses.items():\n            for add, command in dict.items():\n                if c == command:\n                    comm_add = var_type + add\n                    if comm_add == \"8E0006\":\n                        comm_add = \"CE0006\"\n                    if (\n                        \"8\" + comm_add[1:] not in comm_list\n                        and \"C\" + comm_add[1:] not in comm_list\n                    ):\n                        comm_list.append(comm_add)\n        # Calls read and adds the result to the dictionary\n    comm_list.sort()\n    # print(comm_list)\n    i = 0\n    while i &lt;= len(comm_list) - 1:\n        k = 1\n        # print(f\"Looking from: {hex(int(comm_list[i], 16))[2:].upper()}\")\n        for j in range(8):\n            if hex(int(comm_list[i], 16) + j)[2:].upper() in comm_list:\n                # print(\"Found: \" + hex(int(comm_list[i], 16) + j)[2:].upper())\n                idx = comm_list.index(hex(int(comm_list[i], 16) + j)[2:].upper())\n                k = j + 1\n        # print(f\"Calling read with {comm_list[i]}, length {k}\")\n        ret_dict.update(await self._variable_area_read(comm_list[i], k))\n        if k &gt; 1:\n            i = idx\n        i += 1\n    for c in list(ret_dict.keys()):\n        if c not in comm and c not in self.status_labels:\n            del ret_dict[c]\n    if (\n        \"Status\" not in comm\n        and len(comm) != len(ret_dict)\n        or \"Status\" in comm\n        and len(comm) != len(ret_dict) - 16\n    ) and not ignoreError:\n        # print(f\"comm is {comm}, ret_dict is {ret_dict}\")\n        # print(f\"Error: Not all values were read.\")\n        raise KeyError(\"Not all values were read.\")\n    return ret_dict\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.heat","title":"<code>heat(setpoint)</code>  <code>async</code>","text":"<p>Convenience: Sets the heater setpoint.</p> Example <p>df = run(dev.heat, 0.0)</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>float</code> <p>The desired setpoint</p> required Source code in <code>pyomron/device.py</code> <pre><code>async def heat(self, setpoint: float) -&gt; None:\n    \"\"\"Convenience: Sets the heater setpoint.\n\n    Example:\n        df = run(dev.heat, 0.0)\n\n    Args:\n        setpoint (float): The desired setpoint\n    \"\"\"\n    await self.set({\"Communications_Main_Setting_1\": setpoint})\n    return\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.monitors","title":"<code>monitors()</code>  <code>async</code>","text":"<p>Convenience: Gets the current monitor values.</p> Example <p>df = run(dev.monitors)</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>dict[str, float]</code> <p>The desired setpoint</p> required Source code in <code>pyomron/device.py</code> <pre><code>async def monitors(self) -&gt; dict[str, float]:\n    \"\"\"Convenience: Gets the current monitor values.\n\n    Example:\n        df = run(dev.monitors)\n\n    Args:\n        setpoint (dict[str, float]): The desired setpoint\n    \"\"\"\n    return await self._variable_area_read(\"8E0000\", 6)\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.new_device","title":"<code>new_device(port, unit_no=1, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a new device. Chooses appropriate device based on characteristics.</p> Example <p>dev = run(Omron.new_device, \"/dev/ttyUSB6\")</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The port to connect to.</p> required <code>unit_no</code> <code>int</code> <p>The unit number. Defaults to 1.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>Any</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Device</code> <code>Self</code> <p>The new device.</p> Source code in <code>pyomron/device.py</code> <pre><code>@classmethod\nasync def new_device(cls, port: str, unit_no: int = 1, **kwargs: Any) -&gt; Self:\n    \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n    Example:\n        dev = run(Omron.new_device, \"/dev/ttyUSB6\")\n\n    Args:\n        port (str): The port to connect to.\n        unit_no (int, optional): The unit number. Defaults to 1.\n        **kwargs: Any\n\n    Returns:\n        Device: The new device.\n    \"\"\"\n    if port.startswith(\"/dev/\"):\n        device = SerialDevice(port, **kwargs)\n    byte_list = [\n        \"\\x30\",\n        \"\\x35\",\n        \"\\x30\",\n        \"\\x33\",\n    ]  # Command for controller attribute read\n    byte_list = await cls._prepend(byte_list, unit_no)\n    byte_list = await cls._append(byte_list)\n    byte = bytes(\"\".join(byte_list), \"ascii\")\n    byte += bytes([await cls._bcc_calc(byte_list)])\n    resp = await device._write_readline(byte)\n    await cls._check_end_code(resp)\n    await cls._check_response_code(resp)\n    ret = resp[15:-6].decode(\"ascii\")\n    # Chek using is_model class to see if it matches G3PW\n    if await cls._is_model(ret):\n        return cls(device, unit_no, **kwargs)\n    else:\n        raise ValueError(\"Device is not G3PW\")\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.set","title":"<code>set(comm)</code>  <code>async</code>","text":"<p>Sets value of comm to val.</p> Todo <ul> <li>Could also smartly manage writing if multiple sequential addresses are requested by using one call to variable_area_write() with necessary length but this is low priority because it's not likely we would run into this scenario often</li> </ul> Example <p>df = run(dev.set, {\"Communications Parity\": \"Odd\", 'Output Upper Limit': 100})</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>dict[str, str | float]</code> <p>Command to change in form comm:val</p> required Source code in <code>pyomron/device.py</code> <pre><code>async def set(self, comm: dict[str, str | float]) -&gt; None:\n    \"\"\"Sets value of comm to val.\n\n    Todo:\n        * Could also smartly manage writing if multiple sequential addresses are requested by using one call to variable_area_write() with necessary length but this is low priority because it's not likely we would run into this scenario often\n\n    Example:\n        df = run(dev.set, {\"Communications Parity\": \"Odd\", 'Output Upper Limit': 100})\n\n    Args:\n        comm (dict[str, str | float]): Command to change in form comm:val\n    \"\"\"\n    # Search through addresses to find the address for the comm\n    for c in list(comm.keys()):\n        for var_type, dict in self.addresses.items():\n            for add, command in dict.items():\n                if c == command:\n                    comm_add = var_type + add\n        for var_type, dict in self.C383_notation.items():\n            for add, command in dict.items():\n                if comm[c] == command:\n                    comm[c] = add\n        await self._variable_area_write(comm_add, int(comm[c]))  # Sets the value\n    return\n</code></pre>"},{"location":"device-reference/#pyomron.device.Omron.status","title":"<code>status(value)</code>  <code>async</code>","text":"<p>Reads the operating and error status from a bit field.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The bit field to read from</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Value of each Protection/Error Operation</p> Source code in <code>pyomron/device.py</code> <pre><code>async def status(self, value: str) -&gt; dict[str, str]:\n    \"\"\"Reads the operating and error status from a bit field.\n\n    Args:\n        value (str): The bit field to read from\n\n    Returns:\n        dict[str, str]: Value of each Protection/Error Operation\n    \"\"\"\n    e_m = {0: \"No Error\", 1: \"Error\"}\n    p_m = {0: \"OFF\", 1: \"ON\"}\n    status = [\"Q\"] * 32\n    for i in range(32):\n        if i in [7, 12, 13, 14, 15]:\n            continue\n        elif i &lt; 16:\n            status[i] = e_m[(value &gt;&gt; i) &amp; 1]\n        elif i == 19:\n            status[i] = (\n                \"Initial Setting Level\" if (value &gt;&gt; i) &amp; 1 else \"Operation Level\"\n            )\n        elif i == 20:\n            status[i] = \"Manual\" if (value &gt;&gt; i) &amp; 1 else \"Automatic\"\n        elif i == 21:\n            status[i] = (\n                \"Optimum Cycle Control\" if (value &gt;&gt; i) &amp; 1 else \"Phase Control\"\n            )\n        elif i &lt; 32:\n            status[i] = p_m[(value &gt;&gt; i) &amp; 1]\n    ret_dict = dict(zip(self.status_labels, status))\n    del ret_dict[\"Not used.\"]\n    return ret_dict\n</code></pre>"}]}